#!perl

# DATE
# VERSION

use strict;
use warnings;

use Getopt::Long qw(:config bundling no_ignore_case);
use POSIX qw(ceil);

my $tmp_freq;
my %Opts = (
    mode => 'line',
    ignore_case => 0,
    print_freq => 1,
    # XXX options to limit memory usage, e.g. max keys, max line length, --md5 (like in nauniq), ...
    min_freq => undef,
    max_freq => undef,
);

sub parse_cmdline {
    my $res = GetOptions(
        'bytes|c'   => sub { $Opts{mode} = 'byte' },
        'chars|m'   => sub { $Opts{mode} = 'char' },
        'words|w'   => sub { $Opts{mode} = 'word' },
        'lines|l'   => sub { $Opts{mode} = 'line' },
        'number|n'  => sub { $Opts{mode} = 'number' },
        'integer|i' => sub { $Opts{mode} = 'integer' },
        'ignore-case|f' => \$Opts{ignore_case},
        'no-print-freq|F' => sub { $Opts{print_freq} = 0 },
        'print-freq'      => sub { $Opts{print_freq} = 1 },
        'freq=s'    => \$tmp_freq,
        'help|h'  => sub {
            print <<USAGE;
Usage:
  freqtable [OPTIONS]... < INPUT
  freqtable --help (or -h)
Options:
  --bytes, -c
  --chars, -m
  --words, -w
  --lines, -l
  --number, -n
  --integer, -i
  --ignore-case, -f
  --no-print-freq, -F
  --freq N|M-N|M-|-N
For more details, see the manpage/documentation.
USAGE
            exit 0;
        },
    );

    if (defined $tmp_freq) {
        if ($tmp_freq =~ /\A\d+\z/) {
            $Opts{min_freq} = $Opts{max_freq} = $tmp_freq;
        } elsif ($tmp_freq =~ /\A-(\d+)\z/) {
            $Opts{max_freq} = $1;
        } elsif ($tmp_freq =~ /\A(\d+)-\z/) {
            $Opts{min_freq} = $1;
        } elsif ($tmp_freq =~ /\A(\d+)-(\d+)\z/) {
            $Opts{min_freq} = $1;
            $Opts{max_freq} = $2;
        } else {
            warn "freqtable: Invalid value for --freq: '$tmp_freq', ".
                "please specify N|M-N|M-|-N\n";
            $res = 0;
        }
    }

    exit 99 if !$res;
}

sub run {
    my %occurences;
    my $numeric;

    if ($Opts{mode} eq 'byte' || $Opts{mode} eq 'char') {
        @ARGV = (\*STDIN) unless @ARGV;
        for my $fn (@ARGV) {
            my $fh;
            if (ref $fn) {
                $fh = $fn;
            } else {
                open $fh, "<", $fn or do {
                    warn "freqtable: Can't open '$fn': $!\n";
                    next;
                };
            }
            if ($Opts{mode} eq 'byte') {
                binmode $fh;
            } else {
                binmode $fh, ":encoding(utf8)";
            }
            while (1) {
                read $fh, my $block, 4096;
                last if !length $block;
                for (split //, $block) {
                    if ($Opts{ignore_case}) {
                        $occurences{lc $_}++;
                    } else {
                        $occurences{$_}++;
                    }
                }
            }
        } # fn
    } elsif ($Opts{mode} eq 'word') {
        while (defined(my $line = <>)) {
            chomp $line;
            while ($line =~ /(\w+)/g) {
                if ($Opts{ignore_case}) {
                    $occurences{lc $1}++;
                } else {
                    $occurences{$1}++;
                }
            }
        }
    } elsif ($Opts{mode} eq 'line') {
        while (defined(my $line = <>)) {
            chomp $line;
            if ($Opts{ignore_case}) {
                $occurences{lc $line}++;
            } else {
                $occurences{$line}++;
            }
        }
    } elsif ($Opts{mode} eq 'number' || $Opts{mode} eq 'integer') {
        $numeric++;
        while (defined(my $line = <>)) {
            my $num = $Opts{mode} eq 'integer' ? int($line) : $line + 0;
            $occurences{$num}++;
        }
    } else {
        die "freqtable: BUG: Unknown mode '$Opts{mode}'";
    }

    my $fmt;
    for my $k (sort {
        $occurences{$b} <=> $occurences{$a} ||
            ($numeric ? $a <=> $b : $a cmp $b)
    } keys %occurences) {
        my $n = $occurences{$k};
        next if defined $Opts{min_freq} && $n < $Opts{min_freq};
        next if defined $Opts{max_freq} && $n > $Opts{max_freq};
        if ($Opts{print_freq}) {
            unless (defined $fmt) {
                $fmt = "%" . ceil(log($n)/log(10)) . "s\t%s\n";
            }
            printf $fmt, $n, $k;
        } else {
            print $k, "\n";
        }
    }
}

# MAIN

parse_cmdline();
run();

1;
# ABSTRACT: Print frequency table of lines/words/characters/bytes/numbers
# PODNAME:

=head1 SYNOPSIS

 freqtable [OPTIONS] < INPUT


=head1 DESCRIPTION


=head1 OPTIONS

=over

=item * --bytes, -c

=item * --chars, -m

=item * --words, -w

=item * --lines, -l

=item * --number, -n

=item * --integer, -i

=item * --ignore-case, -f

=back


=head1 EXIT CODES

0 on success.

255 on I/O error.

99 on command-line options error.


=head1 FAQ


=head1 SEE ALSO

B<wc>

=cut
